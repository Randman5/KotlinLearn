/**
 * Преобразование типов
 * */

package ipr.chp5._3

/**
 * * Встроенные методы преобразования типов
 * Для преобразования данных одного типа в другой можно использовать встроенные следующие функции, которые есть у базовых типов (Int, Long, Double и т.д.)
 * toByte
 * toShort
 * toInt
 * toLong
 * toFloat
 * toDouble
 * toChar
 * значение не всегда может быть преобразовано к определенному типу. И в этом случае генерируется исключение
 *
 * * Smart cast и оператор is
 * Оператор is позволяет проверить выражение на принадлежность определенному типу данных возвращает true если тип соответствует
 * ограничение
 * 1 smart-преобразования применяются к локальным val-переменным (за исключением делегированных свойств)
 * 2 smart-преобразования применяются к val-свойствам, за исключением свойств с модификатором open (то есть открытых к переопределению в производных классах) или свойств, для которых явным образом определен геттер
 * 3 smart-преобразования применяются к локальным var-переменным (то есть к переменным, определенным в функциях), если переменная не изменяет своего значения в промежутке между проверкой и использованием и не используется в лямбда-выражении, которое изменяет ее, а также не является локальным делегированным свойством
 * 4 к var-свойствам smart-преобразования не применяются
 *
 * * Явные преобразования и оператор as
 * С помощью оператора as мы можем приводить значения одного типа к другому типу
 * небезопасное явное преобразование оператор as если не сможет скастить вылетит NullPointerException
 * безопасное явное преобразование оператор as? если не сможет скастить вернет null
 *
 * */
fun main() {
    val strInInt = "12345".toInt()

    //  оператор is
    println(strInInt is Int) // true так как закастили в Int

    // умное преобразование
    smartCastDemonsration(Person("Tom"))

    // Явные преобразования и оператор as
    val num: String? = "123"
    val number: String = num as String
    println(num is String)// true

    //Явные преобразования и оператор as
    val hello: String? = "Hello Kotlin"
    val message: String =
        hello as String //оператор не безопасного приведения если не сможет скастить то, будет exception
    val message2: String? = hello as? String //оператор безопасного приведения если не сможет скастить то, вернет null
    println(message)

    checkJob(Employee("Mark", "cleaner"))

}

open class Person(var name: String)
class Employee(name: String, var job: String) : Person(name) {
    fun printJob() {
        println("$job")
    }
}

fun smartCastDemonsration(person: Person) {
    when (person) {
        is Employee -> person.printJob() // автоматически понимает что это объект класса Employee
        is Person -> println(person.name)// важно указывать базовый тип последним так как если указать его первым в списке то первый элемент всегда будет true
    }
}

// пример явного преобразования
fun checkJob(person: Person) {
    val employee = person as? Employee // если person передан как employee, то получится скастить если передан чистый Person то вернет null
    if (employee != null) {
        employee.printJob()
    } else {
        println(person.name)
    }
}