/**
 * Scope-функции
 * */

package ipr.chp5._7

/**
 * * Scope-функции (можно перевести как "функции контекста" или "функции области видимости") позволяют выполнить для некоторого объекта некоторый код в виде лямбда-выражение.
 * При вызове подобной функции, создается временная область видимости.
 * В этой области видимости можно обращаться к объекту без использования его имени.
 *
 * * В Kotlin есть пять подобных функций: let, run, with, apply и also.
 * Эти функции похожи по своему действию и различаются прежде всего по параметрам и возвращаемым результатам
 *
 * */
fun main(args: Array<String>) {
    val p = Person("tom", 35)
    p.let {
        it.name = "sam"
        it.age = 22
    }

    // пример с nullable свойствами
    val p2 = Person2(null,null)
    p2.age?.let {
        println("Age: ${it}") // если age null let не сработает

        //Если лямбда-выражение вызывает лишь одну функцию, в которую передается параметр it, то можно сократить вызов - указать после оператора :: название вызываемой функции:
        println("Age: ${::printAge}") // если age null let не сработает
    }

    val agePlus10 = p.age.let { it + 15 } // вернет результат лямбда выражения
    println(agePlus10)// 37


    // with вызывается для выполнения операций над объектом при этом не изменяет сам объект
    val isUpAverageAge = with(p) {
        age != null && age > 30
    }
    println(isUpAverageAge)

    // run работает как with за тем исключением, что run работает как расширение
    val ageOfSam = p.run {
        if(age==null)
            age += 12
        age
    }
    println(p.age) // 22 // действие не влияет на объект
    println(ageOfSam) //34
    //run сахар
    val ageTo = p.age?.run { "notNull" } ?: "null"

    // apply лямбда-выражение в функции apply в качестве параметра this получает объект, действия влияют на объект вызова
    // является построение объекта в виде реализации вариации паттерна "Строитель"
    p.apply {
        age = 1
    }
    println(p.age)// вывод 1

    // also Эта функция аналогична функции apply за тем исключением, что внутри also объект, над которым выполняется блок кода, доступен через параметр it
    p.also {
        it.age = 10
    }
    println(p.age)// вывод 10

}

class Person(var name:String, var age: Int)
class Person2(var name:String?, var age: Int?)

fun printAge(age:Int) = println(age)